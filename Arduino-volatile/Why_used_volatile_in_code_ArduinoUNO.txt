The volatile keyword is used in Arduino programming (and C/C++ in general) to tell the compiler 
that a variable's value can be changed by something outside the normal program flow, 
primarily within interrupt service routines (ISRs). 

Without volatile, the compiler might optimize the code by keeping a copy of the variable in a fast temporary memory location called a register, 
assuming that the main program is the only thing changing it. If an interrupt then changes the original value in RAM, 
the main program might keep using the outdated copy from the register, leading to unpredictable and incorrect behavior. 


Key Reasons for Using volatile in Arduino:

1.Interrupts: This is the most common reason. When a variable is shared between the main loop() function and an ISR (like an interrupt triggered by a button press), 
marking it as volatile ensures that every time the variable is accessed, its value is re-read from RAM (main memory).

2.Preventing Optimization: The keyword is a directive to the compiler, instructing it not to optimize the variable's access. 
This forces the program to fetch the fresh value every single time it's used, 
even if the compiler thinks the value hasn't changed within the current code block.

3.Hardware Interaction (Memory-Mapped Registers): 
In embedded systems, some memory addresses directly correspond to hardware registers (e.g., controlling a peripheral). 
These registers can change state independently of the program's logic. 
Declaring pointers or variables accessing these locations as volatile ensures the correct physical memory is always read. 